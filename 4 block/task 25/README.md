# Практика #1
## Почему динамический полиморфизм не может быть применен к статическим методам?

Динамический полиморфизм не может быть применен к статическим методам, потому что статические методы привязаны к классу на момент компиляции, а не к объекту во время выполнения. Это означает, что решение о том, какой метод будет вызван, происходит на этапе компиляции, а не во время выполнения, как это происходит с динамическим полиморфизмом для экземпляров классов.

Объяснение: Статические методы вызываются через класс, а не через объект. При вызове статического метода компилятор знает, какой метод будет вызван, исходя из типа переменной или класса, в котором этот метод был определен. Таким образом, статические методы не могут использовать динамическую привязку, потому что они не зависят от типа объекта, а только от типа класса, где они были объявлены.

```
class Animal {
    public static void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    public static void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.sound();  // Выведет "Animal makes sound", не "Dog barks"
    }
}
```

В этом примере, несмотря на то что объект a указывает на экземпляр Dog, будет вызван метод sound() из класса Animal, потому что статический метод привязан к типу переменной a, а не к типу объекта, на который она указывает. Это и есть причина, почему динамический полиморфизм не применяется к статическим методам.