# Практика #1
## Объясните, как нужно использовать ключевые слова this и super в подклассах?

В языке Java ключевые слова this и super используются для доступа к членам текущего объекта и его суперкласса соответственно. Эти ключевые слова очень полезны в контексте наследования, так как они позволяют управлять доступом к методам и полям как текущего класса, так и родительского.
1. Использование ключевого слова this

this используется для ссылки на текущий объект, то есть на объект, который вызвал данный метод или конструктор. В подклассе this используется для обращения к полям или методам текущего объекта. Это особенно важно, когда существует конфликт имен между полями суперкласса и подкласса или если нужно вызвать текущий метод.

Пример использования this:
```
class Parent {
    int x = 10;
}

class Child extends Parent {
    int x = 20;

    void printValues() {
        System.out.println("Значение x в текущем объекте: " + this.x);  // обращаемся к полю x текущего объекта (Child)
        System.out.println("Значение x в суперклассе: " + super.x);  // обращаемся к полю x суперкласса (Parent)
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.printValues();
    }
}
```

Когда использовать this:

    Для обращения к полям или методам текущего объекта, особенно когда имя поля или метода совпадает с именем поля или метода родительского класса.
    Для явного вызова текущего конструктора из другого конструктора внутри того же класса.

super используется для ссылки на объект суперкласса. Это позволяет подклассу получить доступ к членам суперкласса, таким как поля, методы и конструкторы. Важно, что super можно использовать только для доступа к методам или полям суперкласса, а также для вызова конструктора суперкласса.

Пример использования super:
```
class Parent {
    void greet() {
        System.out.println("Привет от суперкласса");
    }
}

class Child extends Parent {
    void greet() {
        super.greet();  // вызов метода greet() из суперкласса
        System.out.println("Привет от подкласса");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.greet();
    }
}
```

Когда использовать super:

    Для вызова методов или конструктора суперкласса, которые были переопределены в подклассе.
    Для доступа к полям или методам, которые скрыты или переопределены в подклассе.

Различия и сценарии использования:

    this всегда относится к текущему объекту, т.е. объекту, на котором был вызван метод.
    super всегда относится к объекту суперкласса, и его можно использовать для доступа к методам, полям и конструкторам суперкласса.

# Практика #2
## Объясните как спецификаторы private, protected, public и спецификатор по умолчанию, меняются при наследовании на следующем примере.

private — члены с этим спецификатором доступны только в том классе, в котором они были объявлены. Они не наследуются в подклассы.

protected — члены с этим спецификатором доступны в том же пакете и в подклассах (даже если они находятся в другом пакете).

public — члены с этим спецификатором доступны в любом месте, то есть в любом классе, независимо от того, находятся ли они в том же пакете или нет.

default (пакетный доступ) — члены с этим спецификатором (когда не указан никакой спецификатор) доступны только в том же пакете. Они не доступны вне пакета и не наследуются в подклассы из других пакетов.

```
class A {
  int a1; // package-private (доступен только в том же пакете)
  public int a2; // public (доступен везде)
  protected int a3; // protected (доступен в подклассах и в пределах пакета)
  private int a4; // private (доступен только в классе A)

  void method1() { ... } // package-private (доступен только в том же пакете)
  public void method2() { ... } // public (доступен везде)
  protected void method3() { ... } // protected (доступен в подклассах и в пределах пакета)
  private void method4() { ... } // private (доступен только в классе A)
}

class B extends A {
  void access() {
    // a1 - доступен в этом классе, т.к. он package-private и мы в том же пакете.
    System.out.println(a1); 

    // a2 - доступен везде, т.к. он public.
    System.out.println(a2); 

    // a3 - доступен, т.к. он protected и B является подклассом A.
    System.out.println(a3); 

    // a4 - не доступен, т.к. он private.
    // System.out.println(a4); // Ошибка компиляции!

    // method1() - доступен, т.к. метод package-private доступен в этом пакете.
    method1(); 

    // method2() - доступен, т.к. он public.
    method2(); 

    // method3() - доступен, т.к. он protected.
    method3(); 

    // method4() - не доступен, т.к. он private.
    // method4(); // Ошибка компиляции!
  }
}

class C extends B {
  void access() {
    // a1 - доступен в этом классе, т.к. он package-private и мы в том же пакете.
    System.out.println(a1); 

    // a2 - доступен везде, т.к. он public.
    System.out.println(a2); 

    // a3 - доступен, т.к. он protected и C является подклассом B, который является подклассом A.
    System.out.println(a3); 

    // a4 - не доступен, т.к. он private в классе A.
    // System.out.println(a4); // Ошибка компиляции!

    // method1() - доступен, т.к. он package-private и доступен в этом пакете.
    method1(); 

    // method2() - доступен, т.к. он public.
    method2(); 

    // method3() - доступен, т.к. он protected и C является подклассом B.
    method3(); 

    // method4() - не доступен, т.к. он private в классе A.
    // method4(); // Ошибка компиляции!
  }
}
```