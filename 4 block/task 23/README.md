# Практика #1
## Приведите пример кода, демонстрирующего все три варианта использования ключевого слова super.

Объяснение:

    Обращение к конструктору суперкласса:
        В конструкторе подкласса Child используется super() для вызова конструктора суперкласса Parent. Это необходимо для правильной инициализации полей суперкласса перед выполнением тела конструктора подкласса.

    Доступ к полю суперкласса:
        В методе show() используется super.a, чтобы получить доступ к полю a суперкласса Parent. Обратите внимание, что в подклассе есть также поле a, и с помощью super.a мы явно обращаемся к полю суперкласса.

    Доступ к методу суперкласса:
        В переопределенном методе display() используется super.display(), чтобы вызвать метод display() суперкласса. Это позволяет дополнительно выполнить логику из суперкласса, прежде чем продолжить выполнение метода в подклассе.

```
// Суперкласс
class Parent {
    int a = 10; // Поле суперкласса

    public Parent() {
        System.out.println("Конструктор суперкласса");
    }

    public void display() {
        System.out.println("Метод суперкласса");
    }
}

// Подкласс
class Child extends Parent {
    int a = 20; // Поле подкласса

    // Конструктор подкласса
    public Child() {
        // Использование super() для вызова конструктора суперкласса
        super();  
        System.out.println("Конструктор подкласса");
    }

    // Переопределение метода display
    @Override
    public void display() {
        // Использование super для вызова метода суперкласса
        super.display();
        System.out.println("Метод подкласса");
    }

    public void show() {
        // Использование super для доступа к полю суперкласса
        System.out.println("Поле суперкласса a: " + super.a);
    }
}
```

# Практика #2
## Что случится при вызове метода method() объекта класса C, если переменная a и метод method() не будут определены в классе B, а будут определены только в классе A?

```
class A {
  int a;
  void method() {
    ...
  }

}

class B extends A {
  ...
}

class C extends B {
  ...
  void method() {
    ...
    int a = super.a;
    super.method();
  }
  ...
}
```

Когда метод method() объекта класса C будет вызван в ситуации, описанной в задаче, произойдут следующие действия:
1. Наследование полей и методов:

    Класс C наследует поле a и метод method() от класса A через класс B. В классе B не определено ни поле a, ни метод method(), поэтому они остаются унаследованными от суперкласса A.

2. Использование ключевого слова super:

    В классе C метод method() переопределяется, но в нем используется ключевое слово super для доступа к полю a и методу method() из класса A.
    int a = super.a; - здесь используется super.a, что означает обращение к полю a из суперкласса A. Поскольку в классе B и C нет этого поля, будет использовано поле a из класса A.
    super.method(); - это обращение к методу method() из класса A, так как класс B и класс C не определяют свой собственный метод method().

3. Что произойдет:

    В момент вызова метода method() для объекта класса C произойдут следующие шаги:
        Внутри метода method() из класса C будет выполнена инструкция int a = super.a;, которая получит значение поля a из класса A.
        Затем будет вызван метод super.method();, который вызовет метод method() из класса A.

# Практика #3
## Перепешите следующий код с использованием конструкции this(). Помните, что в каждом конструкторе вызов this() должен быть единственным и первым среди всех операций.

```
class A {
  int a;
  int b;
  int c;
  int z;

  public A() {
    this(0, 0, 0);  // Вызов конструктора с тремя параметрами, передаем значения по умолчанию
  }

  public A(int a) {
    this(a, 0, 0);  // Вызов конструктора с тремя параметрами
  }

  public A(int a, int b) {
    this(a, b, 0);  // Вызов конструктора с тремя параметрами
  }

  public A(int a, int b, int c) {
    this.a = a;
    this.b = b;
    this.c = c;
    z = 1;  // Инициализация z в последнем конструкторе
  }

  // Дополнительные методы можно добавить при необходимости
}
```

Конструктор public A(): Этот конструктор теперь вызывает конструктор с тремя параметрами, передавая значения по умолчанию (в данном случае 0 для всех параметров).

this(0, 0, 0); 

Конструктор public A(int a): Этот конструктор вызывает конструктор с тремя параметрами, передавая a, а остальные параметры принимают значения по умолчанию (0).

this(a, 0, 0); 

Конструктор public A(int a, int b): Здесь мы вызываем конструктор с тремя параметрами, передавая a и b, а c принимает значение по умолчанию (0).

this(a, b, 0);

Конструктор public A(int a, int b, int c): Это основной конструктор, который инициализирует все поля. Поле z всегда инициализируется значением 1.

    this.a = a;
    this.b = b;
    this.c = c;
    z = 1;

Такой подход позволяет избежать повторения кода и использовать цепочку вызовов конструкторов с разными параметрами.