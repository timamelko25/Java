# Практика #1
## Объясните, почему в цикле for (1) будут другие результаты, чем в следующих затем вызовах (2), хотя аргументы одинаковые?

```
public class A {
    public void printNum(Integer i)
    {
        System.out.printf("Integer = %d%n", i);
    }
    public void printNum(int i)
    {
        System.out.printf("int = %d%n", i);
    }
    public void printNum(Float f)
    {
        System.out.printf("Float = %.4f%n", f);
    }
    public void printNum(Number n)
    {
        System.out.println("Number=" + n);
    }
}


public class Main {
    public static void main(String[] args) {
        A a = new A();
        Number[ ] num = {new Integer(1), 11, 1.11f, 11.11 };
        // цикл for (1)
        for (Number n : num) {
            a.printNum(n);
        }
        // (2)
        a.printNum(new Integer(1));
        a.printNum(11);
        a.printNum(1.11f);
        a.printNum(11.11);
    }
}
```

В данном примере происходит использование перегрузки методов с одинаковым именем printNum, но с различными типами параметров. Это связано с тем, что компилятор выбирает метод в зависимости от типа переданных аргументов.

Разница между вызовами в цикле for (1) и вызовами вне цикла (2) заключается в том, как компилятор обрабатывает аргументы, когда они передаются как элементы массива типа Number[], а не напрямую.
Разбор каждого случая:
1. Цикл for (1):

В цикле for массив Number[] num содержит объекты разных типов, которые являются подтипами класса Number. Массив включает:

    new Integer(1) — объект типа Integer, который является подклассом Number.
    11 — примитив типа int, который автоматически упаковался в объект типа Integer (автоупаковка).
    1.11f — примитив типа float, который автоматически упаковался в объект типа Float (автоупаковка).
    11.11 — примитив типа double, который автоматически упаковался в объект типа Double (автоупаковка).

Когда метод printNum вызывается внутри цикла, компилятор выбирает соответствующий метод в зависимости от типа объекта, на который ссылается переменная n.

    Для Integer будет вызван метод printNum(Integer i).
    Для int будет вызван метод printNum(int i), так как int может быть автоматически приведен к Integer, но при вызове метода с типом int компилятор будет выбирать метод с примитивом.
    Для Float будет вызван метод printNum(Float f).
    Для Double будет вызван метод printNum(Number n), так как Double является подтипом Number, а метод printNum(Number n) является более общим и подходит для всех подтипов Number.

Таким образом, внутри цикла метод выбирается по типу конкретного объекта в массиве, что приводит к разным результатам.
2. Внешние вызовы (2):

При вызове методов за пределами цикла аргументы передаются явно:

    a.printNum(new Integer(1)): Здесь передается объект типа Integer, и компилятор выбирает метод printNum(Integer i).
    a.printNum(11): Это примитив типа int. Компилятор выбирает метод printNum(int i) для работы с примитивным типом.
    a.printNum(1.11f): Это примитив типа float. Компилятор выбирает метод printNum(Float f) для работы с типом float.
    a.printNum(11.11): Это примитив типа double. Так как метод для типа double не перегружен, компилятор выбирает метод printNum(Number n), так как Double является подтипом Number.

Итоговый вывод:

Цикл (1):

    new Integer(1) — вызовет printNum(Integer i).
    11 — вызовет printNum(int i).
    1.11f — вызовет printNum(Float f).
    11.11 — вызовет printNum(Number n).

Внешние вызовы (2):

    new Integer(1) — вызовет printNum(Integer i).
    11 — вызовет printNum(int i).
    1.11f — вызовет printNum(Float f).
    11.11 — вызовет printNum(Number n).

Таким образом, результаты будут одинаковыми, но важно отметить, что поведение зависит от типа переданных аргументов в контексте перегрузки методов.